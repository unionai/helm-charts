# ============================================================================
# Union Control Plane Configuration for Self-Hosted Intra-Cluster Deployment
# ============================================================================
# This configuration is for deploying Union control plane in the SAME
# Kubernetes cluster as the Union dataplane (co-located deployment).
#
# IMPORTANT: This file is SELF-CONTAINED and can be used standalone:
#   helm install ... -f values.gcp.selfhosted-intracluster.yaml
#
# Key differences from standard deployment:
# - Uses intra-cluster communication (internal Kubernetes networking)
# - Requires TLS certificates for gRPC/HTTP2 with NGINX
# - Single-tenant mode with explicit organization configuration
# - Direct communication between control plane and dataplane services
#
# NOTE: Common configuration that is not cloud-specific is being migrated
# to values.yaml over time (e.g. selfServeConfig.legacyHosts). Cloud-specific
# overrides (storage, IAM, regions) will remain in this file.
# - Includes all GCP-specific configuration (CloudSQL, GCS, GCP service accounts)
# ============================================================================

# ----------------------------------------------------------------------------
# Configuration Variables to Replace
# ----------------------------------------------------------------------------
# Configure ALL variables below for your self-hosted intra-cluster deployment.
# This file includes both GCP infrastructure configuration AND intra-cluster
# specific settings. Replace all empty "" values with your actual configuration.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# SECTION 1: Global Configuration
# ----------------------------------------------------------------------------
# Configure all global variables for your self-hosted intra-cluster deployment.

global:

  # Region for all resources
  # Example for GCP: "us-central1", "us-east1", "europe-west1"
  GCP_REGION: "us-central1"

  # PostgreSQL database endpoint (CloudSQL for GCP)
  # Example: "10.247.0.3" (Private IP)
  DB_HOST: ""

  # PostgreSQL database name
  # Example: "unionai"
  DB_NAME: ""

  # PostgreSQL username
  # Example: "unionai"
  DB_USER: ""

  # GCS bucket for control plane metadata
  # Example: "union-controlplane-metadata"
  BUCKET_NAME: ""

  # GCS bucket for artifacts storage
  # Example: "union-controlplane-artifacts"
  ARTIFACTS_BUCKET_NAME: ""

  # Name of Kubernetes secret containing the DB password and other service specific secrets.
  # This name is fixed and should not be changed (see values.yaml fix)
  # Note: Secret must contain "pass.txt" key
  KUBERNETES_SECRET_NAME: "union-controlplane-secrets"

  # GCP service account for artifacts service (Workload Identity)
  # Leave empty if artifacts service is disabled
  # Example: "artifacts@PROJECT_ID.iam.gserviceaccount.com"
  ARTIFACT_IAM_ROLE_ARN: ""

  # GCP service account for Flyte services (Workload Identity)
  # Example: "flyteadmin@PROJECT_ID.iam.gserviceaccount.com"
  # Note: Used by flyteadmin, datacatalog, and cacheservice
  FLYTEADMIN_IAM_ROLE_ARN: ""

  # Organization name (must match dataplane orgName)
  # Example: "acme-corp" or "my-organization"
  UNION_ORG: ""

  # Internal Flyteadmin service endpoint
  # Default assumes standard naming in union-cp namespace
  # Override if using different namespace or service name
  FLYTEADMIN_ENDPOINT: "flyteadmin.union-cp.svc.cluster.local:81"

  # Control plane ingress controller FQDN (for intra-cluster routing)
  # Default assumes standard naming in union-cp namespace
  # Override if using different namespace or service name
  CONTROLPLANE_INTRA_CLUSTER_HOST: "controlplane-nginx-controller.union-cp.svc.cluster.local"

  # TLS secret configuration
  # Default assumes standard naming in union-cp namespace
  # Override if using different namespace or secret name
  TLS_SECRET_NAMESPACE: "union-cp"
  TLS_SECRET_NAME: "controlplane-tls-cert"

  # Dataplane ingress controller URL
  # Default assumes standard naming in union namespace
  # Override if using different namespace or service name
  DATAPLANE_ENDPOINT: "http://dataplane-nginx-controller.union.svc.cluster.local:80"

  # GCP project ID for GCS and other GCP resources
  # Example: "my-project-id"
  GOOGLE_PROJECT_ID: ""

  # Union registry repository prefix for control plane images
  # For self-hosted intra-cluster deployments, this uses Union's private registry
  # Example: "registry.unionai.cloud/controlplane"
  IMAGE_REPOSITORY_PREFIX: "registry.unionai.cloud/controlplane"

  # --- Authentication Configuration ---
  # Set all values below to enable OIDC authentication.
  # Supports any OAuth2/OIDC-compliant identity provider.
  #
  # OIDC issuer URL
  # Example: "https://login.example.com/oauth2/default"
  OIDC_BASE_URL: ""
  # Flyteadmin OIDC client ID for browser login flow
  # Example: "0oa1abc2def3ghi4j5k6"
  OIDC_CLIENT_ID: ""
  # CLI client ID for flytectl / uctl (public OAuth app, PKCE flow)
  # Example: "0oa7mno8pqr9stu0v1w2"
  CLI_CLIENT_ID: ""
  # Service-to-service OAuth client ID (confidential app, client_credentials flow)
  # Example: "0oa3xyz4abc5def6g7h8"
  INTERNAL_CLIENT_ID: ""
  # OAuth2 token endpoint
  # Example: "https://login.example.com/oauth2/default/v1/token"
  AUTH_TOKEN_URL: ""

# ----------------------------------------------------------------------------
# SECTION 2: Image Tag Overrides
# ----------------------------------------------------------------------------
# Override image tags for union services (executions, artifacts, etc.)

image:
  tag: 67ac733f8a0f6528ecd18e28a739c4299e314f10

imagePullSecrets:
  - name: union-registry-secret

# ----------------------------------------------------------------------------
# SECTION 3: Core Configuration Overrides
# ----------------------------------------------------------------------------
# These settings configure intra-cluster communication and single-tenant mode.

configMap:
  # Flyteadmin endpoint for intra-cluster communication
  admin:
    endpoint: '{{ .Values.global.FLYTEADMIN_ENDPOINT }}'
    insecure: true
    clientId: '{{ .Values.global.INTERNAL_CLIENT_ID }}'
    clientSecretLocation: "/etc/secrets/union/client_secret"

  # Control plane connection configuration
  connection:
    # Use control plane ingress controller for intra-cluster routing
    # Port 443 required for gRPC (HTTP/2 requires TLS with nginx)
    rootTenantURLPattern: 'dns:///{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}:443'

  # Shared service security configuration
  sharedService:
    security:
      # NOTE: Temporary configuration for single-tenant mode
      # Subject to removal in the future
      singleTenantOrgID: '{{ .Values.global.UNION_ORG }}'

  # Union service connection configuration
  union:
    connection:
      # gRPC requires TLS for HTTP/2 with NGINX
      # Cannot mix HTTP/1.1 and HTTP/2 on same listener without TLS
      insecure: false

      # Skip SSL verification if using self-signed certificates
      insecureSkipVerify: true

    # --- Service-to-service OAuth2 ---
    # Services acquire OAuth2 tokens via client_credentials flow
    # and send them on outgoing calls through nginx, which validates via /me.
    auth:
      enable: true
      type: "ClientSecret"
      clientId: '{{ .Values.global.INTERNAL_CLIENT_ID }}'
      clientSecretLocation: "/etc/secrets/union/client_secret"
      tokenUrl: '{{ .Values.global.AUTH_TOKEN_URL }}'
      authorizationMetadataKey: "flyte-authorization"
      scopes: ["all"]

# ----------------------------------------------------------------------------
# SECTION 3: Console Configuration
# ----------------------------------------------------------------------------

console:
  image:
    repository: "registry.unionai.cloud/controlplane/unionconsole"
    tag: 67ac733f8a0f6528ecd18e28a739c4299e314f10
  env:
    # Single-tenant organization override
    - name: UNION_ORG_OVERRIDE
      value: '{{ .Values.global.UNION_ORG }}'

# ----------------------------------------------------------------------------
# SECTION 4: Extra Kubernetes Objects (OPTIONAL)
# ----------------------------------------------------------------------------
# Additional Kubernetes resources to deploy with the control plane.

extraObjects: []

# Example 1: Create a basic Kubernetes secret (requires manual data population)
# - apiVersion: "v1"
#   kind: "Secret"
#   metadata:
#     name: '{{ .Values.global.KUBERNETES_SECRET_NAME }}'

# Example 2: Use External Secrets Operator with AWS Secrets Manager
# Automatically syncs RDS credentials from AWS Secrets Manager
# Note: GCP_REGION and GCP_MANAGED_DB_SECRET_NAME should be added to globals
# - apiVersion: "external-secrets.io/v1"
#   kind: "SecretStore"
#   metadata:
#     name: "default"
#   spec:
#     provider:
#       aws:
#         region: '{{ .Values.global.GCP_REGION }}'
#         service: "SecretsManager"
#
# - apiVersion: "external-secrets.io/v1"
#   kind: "ExternalSecret"
#   metadata:
#     name: '{{ .Values.global.KUBERNETES_SECRET_NAME }}'
#   spec:
#     data:
#     - remoteRef:
#         key: '{{ .Values.global.GCP_MANAGED_DB_SECRET_NAME }}'
#         property: "password"
#       secretKey: "pass.txt"
#     refreshInterval: "1h"
#     secretStoreRef:
#       kind: "SecretStore"
#       name: "default"
#     target:
#       name: '{{ .Values.global.KUBERNETES_SECRET_NAME }}'

# Example 3: Use cert-manager for TLS certificate management
# Creates a self-signed certificate for intra-cluster TLS
# Requires cert-manager and a ClusterIssuer to be pre-installed
# - apiVersion: "cert-manager.io/v1"
#   kind: "Certificate"
#   metadata:
#     name: "controlplane-selfsigned-tls"
#   spec:
#     dnsNames:
#     - "localhost"
#     - '{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}'
#     ipAddresses:
#     - "127.0.0.1"
#     issuerRef:
#       group: "cert-manager.io"
#       kind: "ClusterIssuer"
#       name: "selfsigned-issuer"
#     secretName: '{{ .Values.global.TLS_SECRET_NAME }}'

# ----------------------------------------------------------------------------
# SECTION 5: Flyte Core Configuration
# ----------------------------------------------------------------------------

flyte:
  # Override region to use GCP_REGION (which has GCP value)
  region: '{{ .Values.global.GCP_REGION }}'

  # Override storage from s3 to gcs
  storage:
    type: gcs
    bucketName: '{{ .Values.global.BUCKET_NAME }}'
    gcs:
      projectId: '{{ .Values.global.GOOGLE_PROJECT_ID }}'

  configmap:
    adminServer:
      admin:
        # Flyteadmin endpoint via control plane ingress
        # Port 443 required for gRPC (HTTP/2 requires TLS with nginx)
        endpoint: 'dns:///{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}:443'
        insecure: false  # Changed: using TLS with self-signed cert
        clientId: '{{ .Values.global.INTERNAL_CLIENT_ID }}'
        clientSecretLocation: "/etc/secrets/client_secret"

      connection:
        # Control plane connection pattern
        # Port 443 required for gRPC (HTTP/2 requires TLS with nginx)
        rootTenantURLPattern: 'dns:///{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}:443'

      sharedService:
        security:
          # NOTE: Temporary configuration for single-tenant mode
          # Subject to removal in the future
          singleTenantOrgID: '{{ .Values.global.UNION_ORG }}'

      # --- OIDC Authentication ---
      # To enable authentication, set server.security.useAuth: true
      # and configure the auth globals in Section 1 above.
      # server:
      #   security:
      #     useAuth: true
      auth:
        httpAuthorizationHeader: "flyte-authorization"
        grpcAuthorizationHeader: "flyte-authorization"
        authorizedUris:
          - "http://flyteadmin:80"
          - 'http://flyteadmin.{{ .Release.Namespace }}.svc.cluster.local:80'
        appAuth:
          authServerType: "External"
          externalAuthServer:
            baseUrl: '{{ .Values.global.OIDC_BASE_URL }}'
          thirdPartyConfig:
            flyteClient:
              clientId: '{{ .Values.global.CLI_CLIENT_ID }}'
              redirectUri: "http://localhost:53593/callback"
              scopes: ["all"]
        userAuth:
          openId:
            baseUrl: '{{ .Values.global.OIDC_BASE_URL }}'
            clientId: '{{ .Values.global.OIDC_CLIENT_ID }}'
            scopes: ["profile", "openid", "offline_access"]
          cookieSetting:
            sameSitePolicy: "LaxMode"
            domain: ""
          idpQueryParameter: "idp"

  # Enable scheduler auth secret mount so flyte-secret-auth is mounted at /etc/secrets/.
  # Set clientSecret: "placeholder" so the subchart renders the secret â€” it must be
  # overwritten externally (e.g. via ExternalSecrets) with the real credential.
  secrets:
    adminOauthClientCredentials:
      enabled: true
      clientSecret: "placeholder"

  flyteadmin:
    image:
      # flyte-core subchart doesn't render templates, must use hardcoded repository
      repository: "registry.unionai.cloud/controlplane/services"
      tag: 67ac733f8a0f6528ecd18e28a739c4299e314f10
    serviceAccount:
      annotations:
        iam.gke.io/gcp-service-account: "{{ .Values.global.FLYTEADMIN_IAM_ROLE_ARN }}"
      imagePullSecrets:
        - name: union-registry-secret

  flytescheduler:
    image:
      # flyte-core subchart doesn't render templates, must use hardcoded repository
      repository: "registry.unionai.cloud/controlplane/services"
      tag: 67ac733f8a0f6528ecd18e28a739c4299e314f10
    serviceAccount:
      imagePullSecrets:
        - name: union-registry-secret

  datacatalog:
    image:
      # flyte-core subchart doesn't render templates, must use hardcoded repository
      repository: "registry.unionai.cloud/controlplane/datacatalog"
      tag: 67ac733f8a0f6528ecd18e28a739c4299e314f10
    serviceAccount:
      annotations:
        iam.gke.io/gcp-service-account: "{{ .Values.global.FLYTEADMIN_IAM_ROLE_ARN }}"
      imagePullSecrets:
        - name: union-registry-secret

  flyteconsole:
    image:
      # flyte-core subchart doesn't render templates, must use hardcoded repository
      repository: "registry.unionai.cloud/controlplane/flyteconsole"
      tag: 67ac733f8a0f6528ecd18e28a739c4299e314f10
    imagePullSecrets:
      - name: union-registry-secret

  cacheservice:
    image:
      # flyte-core subchart doesn't render templates, must use hardcoded repository
      repository: "registry.unionai.cloud/controlplane/services"
      tag: 67ac733f8a0f6528ecd18e28a739c4299e314f10
    serviceAccount:
      annotations:
        iam.gke.io/gcp-service-account: "{{ .Values.global.FLYTEADMIN_IAM_ROLE_ARN }}"
      imagePullSecrets:
        - name: union-registry-secret

# ----------------------------------------------------------------------------
# SECTION 6: Ingress Configuration
# ----------------------------------------------------------------------------

ingress:
  className: controlplane
  tls:
    # TLS configuration for intra-cluster HTTPS
    - hosts:
        - localhost
        - "{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}"
      secretName: "{{ .Values.global.TLS_SECRET_NAME }}"

  # --- Protected Ingress Auth Annotations ---
  # These configure nginx to validate requests via flyteadmin's /me endpoint
  # and redirect unauthenticated users to /login for the OIDC flow.
  # Active when OIDC authentication is enabled (server.security.useAuth: true).
  protectedIngressAnnotations:
    nginx.ingress.kubernetes.io/auth-url: "https://$host/me"
    nginx.ingress.kubernetes.io/auth-signin: "https://$host/login?redirect_url=$escaped_request_uri"
    nginx.ingress.kubernetes.io/auth-response-headers: "Set-Cookie"
    nginx.ingress.kubernetes.io/auth-cache-key: "$http_flyte_authorization$http_cookie"
    nginx.org/websocket-services: "dataproxy-service"

  protectedConsoleIngressAnnotations:
    nginx.ingress.kubernetes.io/auth-url: "https://$host/me"
    nginx.ingress.kubernetes.io/auth-signin: "https://$host/login?redirect_url=$escaped_request_uri"
    nginx.ingress.kubernetes.io/auth-response-headers: "Set-Cookie"
    nginx.ingress.kubernetes.io/auth-cache-key: "$http_flyte_authorization$http_cookie"
    nginx.org/websocket-services: "dataproxy-service"

  protectedIngressAnnotationsGrpc:
    nginx.ingress.kubernetes.io/auth-url: "http://flyteadmin.{{ template \"flyte.namespace\" . }}.svc.cluster.local/me"
    nginx.ingress.kubernetes.io/auth-response-headers: "Set-Cookie"
    nginx.ingress.kubernetes.io/auth-cache-key: "$http_authorization$http_flyte_authorization$http_cookie"

  protectedIngressAnnotationsWithoutSignin:
    nginx.ingress.kubernetes.io/auth-url: "https://$host/me"
    nginx.ingress.kubernetes.io/auth-response-headers: "Set-Cookie"
    nginx.ingress.kubernetes.io/auth-cache-key: "$http_flyte_authorization$http_cookie"
    nginx.org/websocket-services: "dataproxy-service"

# ----------------------------------------------------------------------------
# SECTION 7: NGINX Ingress Controller
# ----------------------------------------------------------------------------

ingress-nginx:
  enabled: true

  # Consistent service naming
  fullnameOverride: controlplane-nginx

  controller:
    service:
      # ClusterIP for intra-cluster only (no external access)
      # Change to LoadBalancer or NodePort for external access
      type: ClusterIP
      ports:
        http: 80
        https: 443

    # Apply TLS certificate to all HTTPS connections
    extraArgs:
      # TODO (DIRECTLY CONFIGURE): Set to the values of {{ .Values.global.TLS_SECRET_NAMESPACE }}/{{ .Values.global.TLS_SECRET_NAME }}
      # nginx-ingress subchart does not support templating here directly.
      default-ssl-certificate: 'union-cp/controlplane-tls-cert'

    # Admission webhooks configuration
    admissionWebhooks:
      enabled: false

      # Optional: Enable with cert-manager
      # enabled: true
      # certManager:
      #   enabled: true
      #   issuerRef:
      #     group: "cert-manager.io"
      #     kind: "ClusterIssuer"
      #     name: "selfsigned-issuer"

      patch:
        enabled: false

    ingressClassResource:
      # Separate ingress class from dataplane
      name: controlplane

# ----------------------------------------------------------------------------
# SECTION 8: Service-Specific Configuration
# ----------------------------------------------------------------------------

services:

  # Artifacts service configuration
  artifacts:
    serviceAccount:
      annotations:
        iam.gke.io/gcp-service-account: "{{ .Values.global.ARTIFACT_IAM_ROLE_ARN }}"
    configMap:
      artifactsConfig:
        app:
          artifactBlobStoreConfig:
            container: '{{ .Values.global.ARTIFACTS_BUCKET_NAME }}'
            stow:
              kind: google
              config:
                projectId: '{{ .Values.global.GOOGLE_PROJECT_ID }}'
            type: stow

  # Dataproxy service configuration
  dataproxy:
    configMap:
      dataproxy:
        # Connect to dataplane ingress controller
        secureTunnelTenantURLPattern: '{{ .Values.global.DATAPLANE_ENDPOINT }}'

  # Executions service configuration
  executions:
    configMap:
      executions:
        app:
          adminClient:
            connection:
              # Flyteadmin endpoint for executions service
              endpoint: '{{ .Values.global.FLYTEADMIN_ENDPOINT }}'
              insecure: true
              # --- Auth fields (active when OIDC is enabled) ---
              authorizationHeader: "flyte-authorization"
              clientId: '{{ .Values.global.INTERNAL_CLIENT_ID }}'
              clientSecretLocation: "/etc/secrets/union/client_secret"
              tokenUrl: '{{ .Values.global.AUTH_TOKEN_URL }}'
              scopes: ["all"]

# ----------------------------------------------------------------------------
# SECTION 9: ScyllaDB Configuration
# ----------------------------------------------------------------------------
scylla:
  enabled: true
  # Datacenter NAME (string, not object)
  datacenter: dc1

  # Replication factor (must match members)
  replicationFactor: 3

  # Rack configuration
  racks:
    - name: rack1
      members: 3
      storage:
        capacity: 100Gi 
      resources:
        limits:
          cpu: "500m"
          memory: "1Gi"
        requests:
          cpu: "200m"
          memory: "512Mi"

  developerMode: true

  storageClass:
    provisioner: pd.csi.storage.gke.io
    parameters:
      type: pd-standard


scylla-operator:
  enabled: true
