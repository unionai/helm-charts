flyte:
  userSettings:
    rdsHost: database-1-instance-1.c982kkq6ghd1.us-east-2.rds.amazonaws.com
    dbUser: postgres
    accountNumber: 440744229819
    accountRegion: us-east-2
    bucketName: unionai-staging-byocp-test
  flyteadmin:
    replicaCount: 1
    image:
      repository: 440744229819.dkr.ecr.us-east-2.amazonaws.com/cloud
      tag: 5851360e4ba391b6bef72c333e497d1cac5b7c9d
      pullPolicy: Always
    serviceAccount:
      annotations:
        eks.amazonaws.com/role-arn: arn:aws:iam::440744229819:role/staging-byocp-test-adminflyterole
    podAnnotations:
      kubectl.kubernetes.io/default-container: flyteadmin
    initialProjects:
      - union-health-monitoring
      - flytesnacks

  workflow_scheduler:
    enabled: false
    type: native

  cacheservice:
    enabled: false
    replicaCount: 1
    image:
      repository: 440744229819.dkr.ecr.us-east-2.amazonaws.com/cloud
      tag: 5851360e4ba391b6bef72c333e497d1cac5b7c9d
      pullPolicy: Always

  datacatalog:
    enabled: false
    replicaCount: 1
    image:
      repository: 440744229819.dkr.ecr.us-east-2.amazonaws.com/cloud
      tag: 5851360e4ba391b6bef72c333e497d1cac5b7c9d
      pullPolicy: Always
  flytepropeller:
    enabled: false
  flyteconsole:
    enabled: false
  webhook:
    enabled: false
  cluster_resource_manager:
    enabled: false
  common:
    databaseSecret:
      name: db-pass
      secretManifest:
        # -- Leave it empty if your secret already exists
        # Else you can create your own secret object. You can use Kubernetes secrets, else you can configure external secrets
        # For external secrets please install Necessary dependencies, like, of your choice
        # - https://github.com/hashicorp/vault
        # - https://github.com/godaddy/kubernetes-external-secrets
        apiVersion: v1
        kind: Secret
        metadata:
          name: db-pass
        type: Opaque
        stringData:
          # -- If using plain text you can provide the password here
          pass.txt: "{{ .Values.userSettings.dbPassword }}"
    ingress:
      host: selfhosted.cloud-staging.union.ai
      albSSLRedirect: false
      separateGrpcIngress: true
      annotations:
        kubernetes.io/ingress.class: "nginx"
        nginx.ingress.kubernetes.io/app-root: /console
        # Set RPS (requests per second) to 100, Burst is automatically computed to be 5x that number. If we decide to
        # bump rps, we should consider setting Burst separately through `limit-burst-multiplier`
        nginx.ingress.kubernetes.io/limit-rps: "100"
        nginx.ingress.kubernetes.io/proxy-body-size: 6m
        nginx.ingress.kubernetes.io/proxy-buffer-size: 32k
        nginx.ingress.kubernetes.io/proxy-buffers: 4 32k
        nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
        nginx.ingress.kubernetes.io/proxy-cookie-domain: ~^ .$host
        nginx.ingress.kubernetes.io/server-snippet: |
          client_header_timeout 604800;
          client_body_timeout 604800;
          # Increasing the default configuration from
          #        client_header_buffer_size       1k;
          #        large_client_header_buffers     4 8k;
          # to default of 16k and 32k for large buffer sizes. These sizes are chosen as a short term mediation until we can collect data to reason
          # about expected header sizs (PE-1101).
          # Historically, we have seen is with the previous 8k max buffer size , the auth endpoint of /me would throw 400 Bad request and due to this ingress controller
          # threw a 500 as it doesn't expect this status code on auth request expected range :  200 <= authcall.status(i.e status of /me call) <=300
          # Code link for ref : https://github.com/nginx/nginx/blob/e734df6664e70f118ca3140bcef6d4f1750fa8fa/src/http/modules/ngx_http_auth_request_module.c#L170-L179
          # Now the main reason we have seen 400 bad request is large size of the cookies which contribute to the header size.
          # We should keep reducing the size of what headers are being sent meanwhile we increase this size to mitigate the long header issue.
          client_header_buffer_size 16k;
          large_client_header_buffers 64 32k;
      annotationsUnary:
        nginx.ingress.kubernetes.io/configuration-snippet: |
          # Copy the user id and identity type from the auth response header into the upstream request header
          auth_request_set $user_id $upstream_http_x_user_subject;
          proxy_set_header X-User-Subject $user_id;
          grpc_set_header X-User-Subject $user_id;

          auth_request_set $user_identitytype $upstream_http_x_user_claim_identitytype;
          proxy_set_header X-User-Claim-Identitytype $user_identitytype;
          grpc_set_header X-User-Claim-Identitytype $user_identitytype;      
          
          auth_request_set $user_apporg $upstream_http_x_user_claim_apporg;
          proxy_set_header X-User-Claim-Apporg $user_apporg;
          grpc_set_header X-User-Claim-Apporg $user_apporg;

          auth_request_set $user_handle $upstream_http_x_user_claim_userhandle;
          proxy_set_header X-User-Claim-userhandle $user_handle;
          grpc_set_header X-User-Claim-userhandle $user_handle;

          auth_request_set $groups $upstream_http_x_user_claim_groups;
          proxy_set_header X-User-Claim-groups $groups;
          grpc_set_header X-User-Claim-groups $groups;

          more_set_headers "x-request-id: $request_id";
          proxy_set_header x-request-id $request_id;
          grpc_set_header x-request-id $request_id;

          more_set_headers "X-Orig-Host: $host";
          proxy_set_header X-Orig-Host $host;
          grpc_set_header X-Orig-Host $host;

          # We disallow external services which go through ingress to set this header so that no one can spoof this
          # as we rely on making authorization decisions based on this
          more_set_headers "l5d-client-id";
          # Donot allow to set this internal header which is used for escalated privilges access in serverless
          more_set_headers "x-overriden-org";
      annotationsStreaming:
        nginx.ingress.kubernetes.io/configuration-snippet: |
          # Copy the user id and identity type from the auth response header into the upstream request header
          auth_request_set $user_id $upstream_http_x_user_subject;
          proxy_set_header X-User-Subject $user_id;
          grpc_set_header X-User-Subject $user_id;

          auth_request_set $user_identitytype $upstream_http_x_user_claim_identitytype;
          proxy_set_header X-User-Claim-Identitytype $user_identitytype;
          grpc_set_header X-User-Claim-Identitytype $user_identitytype;

          auth_request_set $user_handle $upstream_http_x_user_claim_userhandle;
          proxy_set_header X-User-Claim-userhandle $user_handle;
          grpc_set_header X-User-Claim-userhandle $user_handle;

          auth_request_set $groups $upstream_http_x_user_claim_groups;
          proxy_set_header X-User-Claim-groups $groups;
          grpc_set_header X-User-Claim-groups $groups;

          more_set_headers "x-request-id: $request_id";
          proxy_set_header x-request-id $request_id;
          grpc_set_header x-request-id $request_id;

          more_set_headers "X-Orig-Host: $host";
          proxy_set_header X-Orig-Host $host;
          grpc_set_header X-Orig-Host $host;

          # We disallow external services which go through ingress to set this header so that no one can spoof this
          # as we rely on making authorization decisions based on this
          more_set_headers "l5d-client-id";
          # Donot allow to set this internal header which is used for escalated privilges access in serverless
          more_set_headers "x-overriden-org";
      protectedIngressAnnotations:
        nginx.org/websocket-services: dataproxy-service
      enableProtectedConsoleIngress: false
      protectedIngressAnnotationsWithoutSignin:
        nginx.org/websocket-services: dataproxy-service
      protectedConsoleIngressAnnotations:
        # Ensure this cache key resolves as non-empty to avoid an unintended hit on a header-less request.
        # Specifically, the cache key should include the configurable authorization header and cookie header.
        # Make sure to update the key if a different authorization header is used.
        nginx.ingress.kubernetes.io/auth-cache-key: $http_flyte_authorization$http_cookie
        nginx.org/websocket-services: dataproxy-service
      protectedIngressAnnotationsGrpc:

  storage:
    # -- Sets the storage type. Supported values are sandbox, s3, gcs and custom.
    type: s3
    # -- bucketName defines the storage bucket flyte will use. Required for all types except for sandbox.
    bucketName: "{{ .Values.userSettings.bucketName }}"
    s3:
      region: "{{ .Values.userSettings.accountRegion }}"
    cache:
      maxSizeMBs: 1024
  db:
    checks: false
    datacatalog:
      database:
        port: 5432
        # -- Create a user called flyteadmin
        username: "{{ .Values.userSettings.dbUser }}"
        host: "{{ .Values.userSettings.rdsHost }}"
        # -- Create a DB called datacatalog (OR change the name here)
        dbname: datacatalog
        passwordPath: /etc/db/pass.txt
        maxIdleConnections: 10
        maxOpenConnections: 20
        connMaxLifeTime: 120s
    admin:
      database:
        port: 5432
        # -- Create a user called flyteadmin
        username: "{{ .Values.userSettings.dbUser }}"
        host: "{{ .Values.userSettings.rdsHost }}"
        # -- Create a DB called postgres (OR change the name here)
        dbname: postgres
        passwordPath: /etc/db/pass.txt
        maxIdleConnections: 10
        maxOpenConnections: 80
        connMaxLifeTime: 120s
    cacheservice:
      database:
        port: 5432
        # -- Create a user called flyteadmin
        username: "{{ .Values.userSettings.dbUser }}"
        host: "{{ .Values.userSettings.rdsHost }}"
        # -- Create a DB called cacheservice (OR change the name here)
        dbname: cacheservice
        passwordPath: /etc/db/pass.txt
        maxIdleConnections: 10
        maxOpenConnections: 20
        connMaxLifeTime: 120s
  configmap:
    cacheserviceServer:
      union:
        internalConnectionConfig:
          enabled: true
          urlPattern: '{{ printf "{{ service }}.union.svc.cluster.local:80" }}'
        connection:
          trustedIdentityClaims:
            externalIdentityClaim: 0oa2n55xystvEjmOD5d7
        auth:
          clientId: 0oa2n55xystvEjmOD5d7
          authorizationMetadataKey: "flyte-authorization"
          scopes:
            - all
      authorizer:
        type: "Noop"
        internalCommunicationConfig:
          enabled: false
          
    adminServer:
      admin:
        authType: ClientSecret
        clientSecretLocation: /etc/secrets/oidc_client_secret
        scopes:
          - all
        authorizationHeader: "flyte-authorization"
        flyteadmin:
          metricsKeys:
            - phase
          useOffloadedInputs: true
          useOffloadedWorkflowClosure: true
        server:
          grpc:
            maxMessageSizeBytes: 16777216
            enableGrpcLatencyMetrics: true
        cloudEvents:
          enable: true
          type: aws
          eventsPublisher:
            eventTypes:
              - workflow
              - node
        auth:
          httpAuthorizationHeader: "flyte-authorization"
          grpcAuthorizationHeader: "flyte-authorization"
          userAuth:
            cookieSetting:
              sameSitePolicy: LaxMode
              domain: default
            idpQueryParameter: "idp"
            openId:
              scopes:
                - profile
                - openid
                - offline_access
          appAuth:
            authServerType: External
            thirdPartyConfig:
              flyteClient:
                scopes:
                  - all
          tokenEndpointProxyPath:
        otel:
          type: otlpgrpc
          otlpgrpc:
            endpoint: http://otel-collector.monitoring.svc.cluster.local:4317
          sampler:
            parentSampler: traceid
            traceIdRatio: 0.001
        authorizer:
          internalCommunicationConfig:
            enabled: false
        union:
          auth:
            type: ClientSecret
            clientSecretLocation: /etc/secrets/oidc_client_secret
            scopes:
              - all
            authorizationMetadataKey: "flyte-authorization"
          internalConnectionConfig:
            enabled: true
            urlPattern: '{{ printf "{{ service }}.{{ service }}.svc.cluster.local:80" }}'
        private:
          app:
            cacheProviderConfig:
              kind: redis
          metrics:
            disable: true
        redisCache:
          passwordSecretName: "redis-cache-password"
        cacheserviceServer:
          otel:
            type: otlpgrpc
            otlpgrpc:
              endpoint: http://otel-collector.monitoring.svc.cluster.local:4317
            sampler:
              parentSampler: traceid
              traceIdRatio: 0.001
          authorizer:
            internalCommunicationConfig:
              enabled: false
          union:
            auth:
              type: ClientSecret
              clientSecretLocation: /etc/secrets/oidc_client_secret
              scopes:
                - all
              authorizationHeader: "flyte-authorization"
          private:
            app:
              cacheProviderConfig:
                kind: redis
          redisCache:
            passwordSecretName: "redis-cache-password"
        domain: { }
      server:
        security:
          useAuth: false
      private:
        app:
          cacheProviderConfig:
            kind: bypass
      authorizer:
        type: "Noop"
        internalCommunicationConfig:
          enabled: false
      cloudEvents:
        enable: false
      union:
        internalConnectionConfig:
          enabled: true
          urlPattern: '{{ printf "{{ service }}.union.svc.cluster.local:80" }}'
        connection:
          trustedIdentityClaims:
            externalIdentityClaim: 0oa2n55xystvEjmOD5d7
        auth:
          clientId: 0oa2n55xystvEjmOD5d7
          authorizationMetadataKey: "flyte-authorization"
          scopes:
            - all
    sharedService:
      metrics:
        scope: "identity:"
    identity:
      app:
        rootTenantURLPattern: dns:///{{ organization }}.cloud-staging.union.ai
        env: staging
        identityProviderConfig:
          okta:
            clientRegistrationEndpointUrl: https://unionai.oktapreview.com
        adminClient:
          connection:
            clientId: 0oa2n55xystvEjmOD5d7
            authorizationHeader: "flyte-authorization"
            scopes:
              - all
  cloudEvents:
    enable: false
  workflow_notifications:
    enabled: false

podMonitor:
  custom:
    enabled: false
  linkerd:
    enabled: false
probe:
  enabled: false

serviceProfile:
  enabled: false

spreadConstraints:
  enabled: false

unionv2:
  enabled: false

dataproxy:
  prometheus:
    enabled: false

artifacts:
  enabled: false

objectstore:
  controlPlane:
    enabled: false

ingress:
  hostnames:
    - selfhosted.cloud-staging.union.ai