# ============================================================================
# Union Dataplane Configuration for Self-Hosted Intra-Cluster Deployment
# ============================================================================
# This configuration is for deploying Union dataplane in the SAME Kubernetes
# cluster as the Union control plane (co-located deployment).
#
# IMPORTANT: This file is SELF-CONTAINED and can be used standalone:
#   helm install ... -f values.gcp.selfhosted-intracluster.yaml
#
# Key differences from standard BYOC deployment:
# - Uses intra-cluster communication (no external networking)
# - No Cloudflare tunnel required
# - Can use self-signed certificates
# - No API key authentication (direct service-to-service)
# - More cost-effective for single-cluster deployments
# - Includes all GCP-specific configuration (GCS, Workload Identity)
# ============================================================================

# ----------------------------------------------------------------------------
# SECTION 1: Global Configuration
# ----------------------------------------------------------------------------
# Configure ALL variables below for your self-hosted intra-cluster deployment.
# This file includes both AWS infrastructure configuration AND intra-cluster
# specific settings.

global:

  # 2. CLUSTER_NAME - Unique cluster identifier
  #    Format: Lowercase alphanumeric with hyphens
  #    Example: "prod-us-east-1" or "staging-cluster"
  #    Note: Must be unique within your organization
  CLUSTER_NAME: ""

  # 3. ORG_NAME - Organization name
  #    Format: RFC 1123 compliant (lowercase alphanumeric and hyphens)
  #    Example: "acme-corp" or "my-organization"
  #    Source: Provided by Union team
  ORG_NAME: ""

  # 5. METADATA_BUCKET - GCS bucket for workflow metadata
  #    Format: Valid GCS bucket name
  #    Example: "my-union-metadata-bucket"
  #    Note: Bucket must exist before deployment
  METADATA_BUCKET: ""

  #    FAST_REGISTRATION_BUCKET - GCS bucket for code uploads
  #    Format: Valid GCS bucket name
  #    Example: "my-union-fast-registration-bucket"
  #    Note: Can be same as metadata bucket or separate
  FAST_REGISTRATION_BUCKET: ""

  #    GCP_REGION - Region for GCS buckets
  #    Format: GCP region code
  #    Example: "us-central1", "us-east1", "europe-west1"
  GCP_REGION: ""

  #    GOOGLE_PROJECT_ID - GCP project ID
  #    Format: GCP project ID
  #    Example: "my-gcp-project"
  GOOGLE_PROJECT_ID: ""

  #    BACKEND_IAM_ROLE_ARN - GCP service account for Union backend services
  #    Format: service-account-name@project-id.iam.gserviceaccount.com
  #    Example: "union-backend@my-project.iam.gserviceaccount.com"
  #    Permissions: GCS access, GCR/Artifact Registry (if private images)
  BACKEND_IAM_ROLE_ARN: ""

  #    WORKER_IAM_ROLE_ARN - GCP service account for workflow execution pods
  #    Format: service-account-name@project-id.iam.gserviceaccount.com
  #    Example: "union-worker@my-project.iam.gserviceaccount.com"
  #    Permissions: GCS access, GCP services used by workflows
  WORKER_IAM_ROLE_ARN: ""

  #    IMAGE_REPOSITORY_PREFIX - GCP Artifact Registry repository prefix
  #    Format: REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME
  #    Example: "us-central1-docker.pkg.dev/my-project/union"
  IMAGE_REPOSITORY_PREFIX: "public.ecr.aws/p0i0a9q8"

  #    CONTROLPLANE_INTRA_CLUSTER_HOST - Control plane ingress controller FQDN
  #    Format: "SERVICE-NAME.NAMESPACE.svc.cluster.local"
  #    Example: "controlplane-nginx-controller.union-cp.svc.cluster.local"
  #    How to find: kubectl get svc -n union-cp | grep nginx-controller
  #    Note: Used for direct communication with control plane
  #    Currently we need to point it to ingress controller service url instead of
  #    one of the control plane service url since operator talks to multiple union
  #    services.(executions for V1, cluster). In the future we will try to avoid going
  #    through ingress as it enforces Auth for the operator today.
  CONTROLPLANE_INTRA_CLUSTER_HOST: ""

  #    QUEUE_SERVICE_HOST - Queue service FQDN in the controlplane
  #    Format: "queue.NAMESPACE.svc.cluster.local:80" port 80 is the grpc port
  #    Example: "queue.union-cp.svc.cluster.local:80"
  #    How to find: kubectl get svc -n union-cp | grep queue
  #    Note: Used for direct communication with queue service from worker pods
  QUEUE_SERVICE_HOST: ""


  #    FLYTEADMIN_ENDPOINT - Internal Flyteadmin service endpoint
  #    Format: "SERVICE-NAME.NAMESPACE.svc.cluster.local:PORT"
  #    Example: "flyteadmin.union-cp.svc.cluster.local:81"
  #    How to find: kubectl get svc -n union-cp flyteadmin
  FLYTEADMIN_ENDPOINT: "flyteadmin.union-cp.svc.cluster.local:81"

  #    CACHESERVICE_ENDPOINT - Internal Cacheservice endpoint
  #    Format: "SERVICE-NAME.NAMESPACE.svc.cluster.local:PORT"
  #    Example: "cacheservice.union-cp.svc.cluster.local:89"
  #    How to find: kubectl get svc -n union-cp cacheservice
  #    Note: Port 89 is the gRPC port for cacheservice
  #
  #    Cache service does not support insecure skip verify, there we can overwrite
  #    the endpoint here to skip nginx as grpc through nginx must use TLS.
  CACHESERVICE_ENDPOINT: ""

# ----------------------------------------------------------------------------
# SECTION 2: Core Identity Configuration (REQUIRED)
# ----------------------------------------------------------------------------
# These values reference the globals defined above.

# ----------------------------------------------------------------------------
# SECTION 2: Core Identity Configuration (REQUIRED)
# ----------------------------------------------------------------------------
# Cloud provider identifier
provider: gcp

# ----------------------------------------------------------------------------
# SECTION 3: Object Storage Configuration (REQUIRED)
# ----------------------------------------------------------------------------
# Configure GCS buckets for workflow metadata and fast registration.
# These buckets must be created before deployment.

storage:
  provider: gcs  # GCS provider (not custom)
  region: '{{ .Values.global.GCP_REGION }}'
  enableMultiContainer: true

  # GCP configuration
  gcp:
    projectId: '{{ .Values.global.GOOGLE_PROJECT_ID }}'
    # Workload Identity provides authentication automatically

# ----------------------------------------------------------------------------
# SECTION 4: Image Configuration
# ----------------------------------------------------------------------------
# Image configuration for Union dataplane components
# Images are pulled from Union's public ECR registry

image:
  union:
    repository: "public.ecr.aws/p0i0a9q8/unionoperator"
    # tag will be set from Chart.AppVersion or can be overridden

# ----------------------------------------------------------------------------
# SECTION 5: Workload Identity (REQUIRED for GCP)
# ----------------------------------------------------------------------------
# Configure Workload Identity for secure GCP access.
# These GCP service accounts must be created with appropriate IAM bindings.

# GCP service account for Union backend services (operator, propeller, etc.)
additionalServiceAccountAnnotations:
  iam.gke.io/gcp-service-account: "{{ tpl .Values.global.BACKEND_IAM_ROLE_ARN . }}"

# GCP service account for workflow execution pods
userRoleAnnotationKey: iam.gke.io/gcp-service-account
userRoleAnnotationValue: "{{ tpl .Values.global.WORKER_IAM_ROLE_ARN . }}"

# ----------------------------------------------------------------------------
# SECTION 6: Cluster Resource Sync Configuration
# ----------------------------------------------------------------------------
# Syncs Kubernetes resources (namespaces, service accounts, quotas) with
# the control plane using intra-cluster communication.

clusterresourcesync:
  config:
    union:
      connection:
        # Control plane host for intra-cluster communication
        # Example: "dns:///controlplane-nginx-controller.union-cp.svc.cluster.local"
        host: 'dns:///{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}'

        # Skip SSL certificate verification for self-signed certs
        # Set to true for self-signed certificates, false for trusted CA certs
        insecureSkipVerify: true

      # Disable authentication for direct intra-cluster service-to-service calls
      auth:
        enable: false

# ----------------------------------------------------------------------------
# SECTION 7: Core Service Configuration
# ----------------------------------------------------------------------------
# Configure dataplane services to communicate with control plane services
# using Kubernetes internal networking (ClusterIP services).

config:
  # Override storage paths to use gs:// instead of s3://
  core:
    propeller:
      rawoutput-prefix: "gs://{{ .Values.global.METADATA_BUCKET }}"
  admin:
    admin:
      # Flyteadmin endpoint (control plane admin service)
      # Example: "flyteadmin.union-cp.svc.cluster.local:81"
      endpoint: '{{ .Values.global.FLYTEADMIN_ENDPOINT }}'

      # Use insecure (non-TLS) connection for intra-cluster HTTP communication
      insecure: true

      # Disable OAuth2 client credentials (not needed for intra-cluster)
      clientId: null
      clientSecretLocation: null

  catalog:
    # Catalog service for task caching and reuse
    catalog-cache:

      type: "cacheservicev2"

      # Control plane host for catalog service
      # Example: "dns:///controlplane-nginx-controller.union-cp.svc.cluster.local"
      cache-endpoint: '{{ .Values.global.CACHESERVICE_ENDPOINT }}'
      endpoint: ""

      # Use insecure connection for intra-cluster communication
      insecure: true

      # Disable admin authentication (direct service-to-service)
      use-admin-auth: false

  k8s:
    plugins:
      k8s:
        # Environment variables injected into all task pods
        default-env-vars:
          # Optionally increase the log level for all execution pods for debugging
          # - LOG_LEVEL: "10"

          # Bypass ingress authentication layer with intra-cluster communication by communicating
          # directly with the queue service.
          - _U_EP_OVERRIDE: 'dns:///{{ .Values.global.QUEUE_SERVICE_HOST }}'

          # Assumed queue service is running with TLS disabled since it's intra-cluster,
          # we can set the following env vars to skip TLS verification for the queue service.
          - _U_INSECURE: true
          - _U_INSECURE_SKIP_VERIFY: false

  union:
    connection:
      # Control plane connection for Union services
      # Example: "dns:///controlplane-nginx-controller.union-cp.svc.cluster.local"
      host: 'dns:///{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}'

      # Skip SSL verification for self-signed certificates
      insecureSkipVerify: true

    auth:
      # Disable OAuth authentication for intra-cluster communication
      enable: false

  operator:
    # Disable Cloudflare tunnel (not needed for intra-cluster)
    enableTunnelService: false

    # Disable billable usage collector (typically for Union-managed control planes)
    billableUsageCollector:
      enabled: false

    # Override storage paths and GCP project ID
    clusterData:
      metadataBucketPrefix: "gs://{{ .Values.global.METADATA_BUCKET }}"
      gcpProjectId: "{{ .Values.global.GOOGLE_PROJECT_ID }}"

    # Override dependencies heartbeat to only check proxy
    dependenciesHeartbeat:
      proxy:
        endpoint: 'http://union-operator-proxy:10254'

# ----------------------------------------------------------------------------
# Executor Configuration
# ----------------------------------------------------------------------------
# Configure how workflow tasks are executed.

executor:
  config:
    unionAuth:
      # Disable API key injection (not needed for intra-cluster communication)
      injectSecret: false

# ----------------------------------------------------------------------------
# Ingress Configuration
# ----------------------------------------------------------------------------
# Configure ingress for external access to dataplane services.

# Extra Kubernetes objects to be deployed alongside Union
extraObjects: []

# Ingress configuration for Union dataplane and serving
ingress:
  dataproxy:
    class: "dataplane"
  enabled: true

  # Ingress architecture for serving will change in the future.
  # This is a temporary configuration for intra-cluster deployments.
  serving:
    # Default to using the intra-cluster host for serving
    hostOverride: "*.apps.{{ .Values.global.CONTROLPLANE_INTRA_CLUSTER_HOST }}"
    # Assume the same ingress class as the dataproxy
    class: "dataplane"

# NGINX Ingress controller for dataplane
ingress-nginx:
  enabled: true

  # Service name for the ingress controller
  # This creates a service: "dataplane-nginx-controller"
  # External traffic enters through this service
  fullnameOverride: "dataplane-nginx"

  controller:
    service:
      # Use ClusterIP for intra-cluster only (no external LoadBalancer)
      # Change to LoadBalancer or NodePort for external access
      type: "ClusterIP"
      ports:
        http: 80
        https: 443

    ingressClassResource:
      # Ingress class name used in Ingress resources
      name: "dataplane"

# ----------------------------------------------------------------------------
# Operator Configuration
# ----------------------------------------------------------------------------

operator:
  # Disable Cloudflare tunnel (not needed for intra-cluster deployment)
  enableTunnelService: false

# ----------------------------------------------------------------------------
# Monitoring Configuration
# ----------------------------------------------------------------------------

# Prometheus for metrics collection and monitoring
prometheus:
  prometheusOperator:
    admissionWebhooks:
      # Disable admission webhooks by default
      # Enable if you have cert-manager installed
      enabled: true

      # Optional: Enable webhooks with cert-manager
      # enabled: true
      #certManager:
      #  enabled: true
      #  issuerRef:
      #    group: "cert-manager.io"
      #    kind: "ClusterIssuer"
      #    name: "selfsigned-issuer"

      patch:
        enabled: true

# ----------------------------------------------------------------------------
# Secrets Configuration
# ----------------------------------------------------------------------------

secrets:
  admin:
    # Disable admin secret creation (OAuth not used for intra-cluster)
    enable: false
    create: false

# ----------------------------------------------------------------------------
# App Serving Configuration (Work in Progress)
# ----------------------------------------------------------------------------

serving:
  auth:
    # Disable authentication for serving (work in progress)
    enabled: false

# ----------------------------------------------------------------------------
# SECTION 6: Logging Configuration (REQUIRED)
# ----------------------------------------------------------------------------
# FluentBit collects and forwards logs to the control plane.

fluentbit:
  serviceAccount:
    name: fluentbit-system
    # GKE Workload Identity annotation to grant FluentBit write access to GCS.
    # The GCP service account must have roles/storage.objectAdmin on the bucket
    # and the KSA must be bound via roles/iam.workloadIdentityUser.
    annotations: {}
    # annotations:
    #   iam.gke.io/gcp-service-account: "<GSA_NAME>@<PROJECT_ID>.iam.gserviceaccount.com"

# ----------------------------------------------------------------------------
# SECTION 7: Enable Opencost used for getting instance level cost data.
# ----------------------------------------------------------------------------
opencost:
  # Currently we are disabling this as V2 console is not yet integrated with this cost data.
  enabled: false

# ----------------------------------------------------------------------------
# SECTION 8: Override priority class due to GKE restriction where it doesn't
#            allow running pods with system-cluster-critical other core kube
#            components.
# ----------------------------------------------------------------------------
flytepropeller:
  priorityClassName: ""

flytepropellerwebhook: {}
